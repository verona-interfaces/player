asyncapi: 2.0.0
info:
  title: Verona Player Module
  version: '2.1.0'
  description: This is one part of the Verona Online Assessment Standards.
    All messages are sent via the postMessage function of the html page. The player takes the page root of its parent
    as target (parent.window), and the application binds the function call to the iframe element of the player.

    Most important, the message body carries as first parameter the operationId of the message.

  license:
    name: MIT

channels:
  vopReadyNotification:
    subscribe:
      operationId: vopReadyNotification
      summary: player announces readiness
      description: The player announces that it's code is loaded and initialized so the communication can start.
      message:
        payload:
          type: object
          properties:
            apiVersion:
              type: string
              pattern: '^\d+\.\d+.\d+$'
              description: This lets the application know what API version the player supports. If this does not
                fit the API version the application can offer, the player should not be used. An exception
                should be thrown.
            responseType:
              type: string
              description: This string is important when the responses and the logs are processed. Every data
                transformation afterwards requires to know where the data came from. The type can be an ID of the
                player or a known data format.
          required:
            - apiVersion

  vopStartCommand:
    publish:
      operationId: vopStartCommand
      summary: application orders player to start
      description: The application sends parameters for running the unit and commands the start of user interaction.
      message:
        contentType: application/json
        payload:
          type: object
          properties:
            sessionId:
              type: string
              description: The session id flags all communication from this moment on. If a message has no or empty
                session id, it's not processed. The session id is unique and was generated by the application. Any
                simple algorithm would work. The session id helps to link the correct unit with the
                data of the message. Using the id of the player hosting html element is less reliable, because the
                element could be reused with another unit (via this StartCommand).
            unitDefinition:
              type: string
              format: byte
              description: The definition of the unit (if given) lets the player adapt. An audio player gets it's audio
                sequence, a choice player gets it's options...
            responses:
              $ref: "#/components/schemas/ResponseType"
              description: If there is any state what should be restored, then this is the information for that.
            playerConfig:
              $ref: "#/components/schemas/PlayerConfig"
              description: This data supplies some information or instruction about this specific run of the unit
                (number, unit title, some behavioral data for the player).
          required:
            - sessionId


  vopStateChangedNotification:
    subscribe:
      operationId: vopStateChangedNotification
      summary: state has changed
      description: The state of the unit and/or of the player has changed. Some logs entries might be sent.
      message:
        contentType: application/json
        payload:
          type: object
          properties:
            sessionId:
              type: string
              description: Unique identificator of the execution of the unit (one run). This id was generated by
                the application and first given to the player via StartCommand.
            timeStamp:
              type: string
              format: date-time
              description: Ensures, that later arriving states are ignored.
            unitState:
              $ref: "#/components/schemas/UnitState"
              description: To be stored, evaluated etc. This is the main yield, the responses.
            playerState:
              $ref: "#/components/schemas/PlayerState"
              description: Information important only for the application to ensure the correct visual, such as
                navigation buttons.
            log:
              type: array
              items:
                $ref: "#/components/schemas/LogEntry"
              description: Log entries (lean version) add some information to the response in order to understand
                the response process better or (rich version) let the analyst replay every change of the state.
          required:
            - sessionId
            - timeStamp

  vopPageNavigationCommand:
    publish:
      operationId: vopPageNavigationCommand
      summary: page navigation
      description: The application wants the player to navigate to a specific page.
      message:
        contentType: application/json
        payload:
          type: object
          properties:
            sessionId:
              type: string
              description: Unique identificator of the execution of the unit (one run). This id was generated by
                the application and first given to the player via StartCommand.
            target:
              type: string
              description: Id of the page matching one of the validPages given to the application by the playerState
                data of the StateChangedNotification.
          required:
            - sessionId
            - target
  vopUnitNavigationRequestedNotification:
    subscribe:
      operationId: vopUnitNavigationRequestedNotification
      summary: unit navigation
      description: The user has triggered a navigation request.
      message:
        contentType: application/json
        payload:
          type: object
          properties:
            sessionId:
              type: string
              description: Unique identificator of the execution of the unit (one run). This id was generated by
                the application and first given to the player via StartCommand.
            targetRelative:
              enum:
                - next
                - previous
                - first
                - last
                - end
              description: Refers to a unit relative to the position of the current unit or to the first or last
                unit. The key 'end' requests the finish of the test (close and go to the thank you page).
          required:
            - sessionId
            - target

  vopGetStateRequest:
    publish:
      operationId: vopGetStateRequest
      summary: request for state
      description: The application wants the player to report the last state and (optional) to stop interaction.
      message:
        contentType: application/json
        payload:
          type: object
          properties:
            sessionId:
              type: string
              description: Unique identificator of the execution of the unit (one run). This id was generated by
                the application and first given to the player via StartCommand.
            stop:
              type: boolean
              description: If true, the player should not accept any user interaction anymore to be sure, that all
                states of the unit are reported. Usually, you will do so just before unloading the player and
                prepare for the next unit.
          required:
            - sessionId
            - stop

  vopGetStateResponse:
    subscribe:
      operationId: vopGetStateResponse
      summary: responding to state request
      description: The player sends the last unit state.
      message:
        contentType: application/json
        payload:
          type: object
          properties:
            sessionId:
              type: string
              description: Unique identificator of the execution of the unit (one run). This id was generated by
                the application and first given to the player via StartCommand.
            timeStamp:
              type: string
              format: date-time
            unitState:
              $ref: "#/components/schemas/UnitState"
              description: See StateChangedNotification.
            playerState:
              $ref: "#/components/schemas/PlayerState"
              description: See StateChangedNotification.
            log:
              type: array
              items:
                $ref: "#/components/schemas/LogEntry"
              description: See StateChangedNotification.
          required:
            - sessionId
            - timeStamp

  vopStopCommand:
    publish:
      operationId: vopStopCommand
      summary: stop player
      description: The application wants the player to stop all activities and user interaction.
      message:
        contentType: application/json
        payload:
          type: object
          properties:
            sessionId:
              type: string
              description: Unique identificator of the execution of the unit (one run). This id was generated by
                the application and first given to the player via StartCommand.
          required:
            - sessionId

  vopContinueCommand:
    publish:
      operationId: vopContinueCommand
      summary: continue player
      description: The application wants the player to continue all activities and user interaction.
      message:
        contentType: application/json
        payload:
          type: object
          properties:
            sessionId:
              type: string
              description: Unique identificator of the execution of the unit (one run). This id was generated by
                the application and first given to the player via StartCommand.
          required:
            - sessionId

  vopWindowsFocusChangedNotification:
    subscribe:
      operationId: vopWindowsFocusChangedNotification
      summary: the window of the player has got or lost the focus
      description: In some use cases like exam mode the host must know whether the host or the player has the
        window's focus. If none of these windows have the focus (i. e. the testee has left the test), some logging or
        warning could be necessary. The player listens to the window events 'blur' and 'focus'.
      message:
        contentType: application/json
        payload:
          type: object
          properties:
            timeStamp:
              type: string
              format: date-time
              description: Ensures, that later arriving states are ignored.
            hasFocus:
              type: boolean
              description: true if the player got the focus, false if it lost the focus.
          required:
            - timeStamp
            - hasFocus

components:
  schemas:
    ResponseType:
      description: These are all data needed for restoring the unit state after reload. This is also the
        basis for extracting the responses of the testee. Because the load of the whole state could be huge,
        we can split the state into chunks. So the data structure is "key of chunk" => "chunk data". In order to
        restore the unit state or to analyse the response, all chunks are needed. If a chunk is sent twice, the
        first one (accourding to the time stamp) should be overwritten.
      type: object
      additionalProperties:
        type: string
        format: byte
    LogEntry:
      description: The player can sent any information about events happening during the interaction phase.
      type: object
      properties:
        timeStamp:
          type: string
          format: date-time
        key:
          type: string
          description: This key might help to classify the events afterwards.
        content:
          type: string
          format: byte
          description: Some information to specify the event.
      required:
        - timeStamp
        - key
    PlayerState:
      type: object
      properties:
        state:
          enum:
            - running
            - stopped
        currentPage:
          type: string
        validPages:
          description: These data are structured as "page key" => "page label", so we have (1) keys for navigation
            commands or state notifications and (2) strings as labels of navigation buttons if needed.
          type: object
          additionalProperties:
            type: string
      required:
        - state
        - currentPage
        - validPages
    UnitState:
      type: object
      properties:
        responses:
          $ref: "#/components/schemas/ResponseType"
        presentationProgress:
          enum:
            - none
            - some
            - complete
        responseProgress:
          enum:
            - none
            - some
            - complete
            - complete-and-valid
    PlayerConfig:
      type: object
      properties:
        unitNumber:
          type: integer
          minimum: 1
        unitTitle:
          type: string
          maxLength: 50
        unitId:
          type: string
          maxLength: 20
        stateReportPolicy:
          enum:
            - none
            - eager
            - on-demand
        logPolicy:
          enum:
            - disabled
            - lean
            - rich
        pagingMode:
          enum:
            - separate
            - scroll
            - scroll-snap

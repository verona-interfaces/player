# Verona Inferfaces Specification &quot;Player&quot; 4.0.0 documentation



This is one part of the Verona Online Assessment Standards. All messages are sent via the postMessage function of the html page. The player takes the page root of its parent as target (parent.window), and the application binds the function call to the iframe element of the player.
Most important, the message body carries as first parameter the operationId of the message.
The html page MUST contain a <script>-tag with metadata. The syntax and structure of these data are described [here](https://github.com/verona-interfaces/metadata/#readme).

## Table of Contents




* [Channels](#channels)










## Channels



<a name="channel-vopReadyNotification"></a>





#### Channel Parameters







###  `subscribe` vopReadyNotification

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>metadata </td>
  <td>string</td>
  <td><p>Via this property, the player sends the stringified metadata object definied as json-ld in the header of the html file. See <a href="https://github.com/verona-interfaces/metadata/#readme">here</a> for more information.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "metadata": "string"
}
```








<a name="channel-vopStartCommand"></a>





#### Channel Parameters







###  `publish` vopStartCommand

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>The session id flags all communication. If a message has no or empty session id, it's not processed. The session id is unique and was generated by the application. Any simple algorithm would work. The session id helps to link the correct unit with the data of the message. Using the id of the player hosting html element is less reliable, because the element could be reused with another unit.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>unitDefinition </td>
  <td>string</td>
  <td><p>The definition of the unit (if given) lets the player adapt. An audio player gets it's audio sequence, a choice player gets it's options...</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>unitDefinitionType </td>
  <td>string</td>
  <td><p>This lets the player the unit definition format know. This might avoid UI mess after getting old definitions.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>unitState </td>
  <td>object</td>
  <td><p>If there is any state what should be restored, then this is the information for that.</p>
</td>
  <td><em>Any</em></td>
</tr>





<tr>
  <td>unitState.dataParts </td>
  <td>object</td>
  <td><p>These data are used by the player to restore the former response state and by data processing systems to analyse the responses. The host must buffer all data parts, because the player might send only changed data parts, not always the whole package. The host stores all parts but only the last given version (respect timeStamp!). Every data part is identified by a unique key, the data is stored as serialized object (string).</p>
</td>
  <td><em>Any</em></td>
</tr>











<tr>
  <td>unitState.presentationProgress </td>
  <td>string</td>
  <td><p>This reports the progress of presentation of unit content. The host can enable or disable the navigation to the next unit depending on that value. For example, all audio elements are required to be played or all pages must be presented to the page bottom. This way, giving no response to an item is always intended.</p>
</td>
  <td><code>none</code>, <code>some</code>, <code>complete</code></td>
</tr>









<tr>
  <td>unitState.responseProgress </td>
  <td>string</td>
  <td><p>This reports the progress of responding. The host can enable or disable the navigation to the next unit depending on that value. The value 'complete' announces not only that all required responses are given but that these responses are valid too. The value 'complete' can be sent even not all responses are given - the host is interested only in REQUIRED responses. So make sure to mark all response elements correctly corresponding to this behaviour.</p>
</td>
  <td><code>none</code>, <code>some</code>, <code>complete</code></td>
</tr>









<tr>
  <td>unitState.unitStateDataType </td>
  <td>string</td>
  <td><p>This string specifies the format of the data stored in dataParts (value). Every transformation or analysis of stored unit data requires knowledge about the format. When the host sends data to the player to restore the former unit state, the player should check the given data type to avoid data mess after getting an old data type.</p>
</td>
  <td><em>Any</em></td>
</tr>











    
      
<tr>
  <td>playerConfig </td>
  <td>object</td>
  <td><p>This data supplies some information or instruction about this specific run of the unit (number, unit title, some behavioral data for the player).</p>
</td>
  <td><em>Any</em></td>
</tr>





<tr>
  <td>playerConfig.unitNumber </td>
  <td>integer</td>
  <td><p>The player might show the numbering of the current unit to ease the navigation.</p>
</td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>playerConfig.unitTitle </td>
  <td>string</td>
  <td><p>The player might show the title of the current unit. Unless the unit definition could consist of a title, the host might decide to change the title. For example, this is necessary if one unit appears more then once in a booklet.</p>
</td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>playerConfig.unitId </td>
  <td>string</td>
  <td><p>The player might include the internal unit id in state variables or logs.</p>
</td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>playerConfig.stateReportPolicy </td>
  <td>string</td>
  <td><p>The host expects the player to send no state changes (e. g. for use case &quot;preview mode&quot;), all changes when happening or only on demand. The latter might lead to better performance. In this case, the host triggers state report by sending 'vopGetStateRequest'.</p>
</td>
  <td><code>none</code>, <code>eager</code>, <code>on-demand</code></td>
</tr>









<tr>
  <td>playerConfig.logPolicy </td>
  <td>string</td>
  <td><p>The host expects the player to send no logs, only important logs, all possible logs or even logs for debugging purposes. This is a guideline. The player can decide what exactly the logging consists of.</p>
</td>
  <td><code>disabled</code>, <code>lean</code>, <code>rich</code>, <code>debug</code></td>
</tr>









<tr>
  <td>playerConfig.pagingMode </td>
  <td>string</td>
  <td><p>If the player makes it optional, then the page presentation can be changed by the host. The pages are presented separately, concatenated to one big page or concatenated in snap mode (scrolling vertically, but only one page is visible at a time).</p>
</td>
  <td><code>separate</code>, <code>concat-scroll</code>, <code>concat-scroll-snap</code></td>
</tr>









<tr>
  <td>playerConfig.enabledNavigationTargets </td>
  <td>array(string)</td>
  <td><p>This lets the player know, what navigation target is enabled to natigate to. The player might then alter the presentation of responding buttons.</p>
</td>
  <td><em>Any</em></td>
</tr>











<tr>
  <td>playerConfig.startPage </td>
  <td>string</td>
  <td><p>This requests the player to navigate to a certain page after loading. The host might know this page id from former usages of the unit.</p>
</td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>playerConfig.directDownloadUrl </td>
  <td>string</td>
  <td><p>After starting the player and loading the unit definition and former responses, it might be necessary to load additional code or data from the server. This data is identified by an resource ID (ususally a file name). The player can download this resource by itself without further interaction with the host frontend. The property directDownloadUrl provides the url for download. The player extends this url by an url separator &quot;/&quot; and the resource ID (uri-encoded if needed).</p>
</td>
  <td><em>Any</em></td>
</tr>











    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "idk8ur5jf9ru5jk",
  "unitDefinition": "iqb-scripted::1.4.0 title::Testscript Title2??Hilfetext2 multiple-choice::mc_var1::1::Multiple Choice Feld: ::Choice1##Choice2##Choice3??Hilfetext1 drop-down::dd_var1::1::Dropdown Feld: ::Choice1##Choice2##Choice3??Hilfetext1 checkbox::check_var1::0::Ja klick mal! if-start::dd_var1::1 input-text::jajaj::sap osjxapsoxa if-else input-text::jajaj22::sap osjxapsoxa UUUU text::NOT Choice1 if-end",
  "unitDefinitionType": "iqb-scripted@1.4.0",
  "unitState": {
    "dataParts": {
      "page1": "{\"a\": 1, \"b\": 233}",
      "page2": "{\"c\": \"sehr gut!\", \"d\": true}"
    },
    "presentationProgress": "none",
    "responseProgress": "some",
    "unitStateDataType": "iqb-key-value@2.1.2"
  },
  "playerConfig": {
    "unitNumber": "14",
    "unitTitle": "Ein wunderbarer Ausflug",
    "unitId": "M24093EX",
    "stateReportPolicy": "eager",
    "logPolicy": "lean",
    "pagingMode": "concat-scroll",
    "enabledNavigationTargets": [
      "next"
    ],
    "startPage": "page5",
    "directDownloadUrl": "https://www.iqb-testcenter.de/download/iskeid-34e845-didmmemdkek"
  }
}
```








<a name="channel-vopStateChangedNotification"></a>





#### Channel Parameters







###  `subscribe` vopStateChangedNotification

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>The session id flags all communication. If a message has no or empty session id, it's not processed. The session id is unique and was generated by the application. Any simple algorithm would work. The session id helps to link the correct unit with the data of the message. Using the id of the player hosting html element is less reliable, because the element could be reused with another unit.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>timeStamp </td>
  <td>string</td>
  <td><p>Ensures, that later arriving states are ignored.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>unitState </td>
  <td>object</td>
  <td><p>To be stored, evaluated etc. This is the main yield, the responses.</p>
</td>
  <td><em>Any</em></td>
</tr>





<tr>
  <td>unitState.dataParts </td>
  <td>object</td>
  <td><p>These data are used by the player to restore the former response state and by data processing systems to analyse the responses. The host must buffer all data parts, because the player might send only changed data parts, not always the whole package. The host stores all parts but only the last given version (respect timeStamp!). Every data part is identified by a unique key, the data is stored as serialized object (string).</p>
</td>
  <td><em>Any</em></td>
</tr>











<tr>
  <td>unitState.presentationProgress </td>
  <td>string</td>
  <td><p>This reports the progress of presentation of unit content. The host can enable or disable the navigation to the next unit depending on that value. For example, all audio elements are required to be played or all pages must be presented to the page bottom. This way, giving no response to an item is always intended.</p>
</td>
  <td><code>none</code>, <code>some</code>, <code>complete</code></td>
</tr>









<tr>
  <td>unitState.responseProgress </td>
  <td>string</td>
  <td><p>This reports the progress of responding. The host can enable or disable the navigation to the next unit depending on that value. The value 'complete' announces not only that all required responses are given but that these responses are valid too. The value 'complete' can be sent even not all responses are given - the host is interested only in REQUIRED responses. So make sure to mark all response elements correctly corresponding to this behaviour.</p>
</td>
  <td><code>none</code>, <code>some</code>, <code>complete</code></td>
</tr>









<tr>
  <td>unitState.unitStateDataType </td>
  <td>string</td>
  <td><p>This string specifies the format of the data stored in dataParts (value). Every transformation or analysis of stored unit data requires knowledge about the format. When the host sends data to the player to restore the former unit state, the player should check the given data type to avoid data mess after getting an old data type.</p>
</td>
  <td><em>Any</em></td>
</tr>











    
      
<tr>
  <td>playerState </td>
  <td>object</td>
  <td><p>Information important only for the application to ensure the correct visual, such as navigation buttons.</p>
</td>
  <td><em>Any</em></td>
</tr>





<tr>
  <td>playerState.state </td>
  <td>string</td>
  <td></td>
  <td><code>running</code>, <code>stopped</code></td>
</tr>









<tr>
  <td>playerState.validPages </td>
  <td>object</td>
  <td><p>These data are structured as &quot;page key&quot; =&gt; &quot;page label&quot;, so we have (1) keys for navigation commands or state notifications and (2) strings as labels of navigation buttons if needed.</p>
</td>
  <td><em>Any</em></td>
</tr>











<tr>
  <td>playerState.currentPage </td>
  <td>string</td>
  <td><p>Key of the page currently presented. This key is taken from the list of valid pages. If the paging mode is 'concat-scroll', the first page with parts in view port is taken as current page.</p>
</td>
  <td><em>Any</em></td>
</tr>











    
      
<tr>
  <td>log </td>
  <td>array(object)</td>
  <td><p>Log entries (lean version) add some information to the response in order to understand the response process better or (rich version) let the analyst replay every change of the state.</p>
</td>
  <td><em>Any</em></td>
</tr>








<tr>
  <td>log.timeStamp </td>
  <td>string</td>
  <td></td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>log.key </td>
  <td>string</td>
  <td><p>This key might help to classify the events afterwards.</p>
</td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>log.content </td>
  <td>string</td>
  <td><p>Some information to specify the event.</p>
</td>
  <td><em>Any</em></td>
</tr>










    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "idk8ur5jf9ru5jk",
  "timeStamp": "2021-11-10T10:22:25Z",
  "unitState": {
    "dataParts": {
      "page1": "{\"a\": 1, \"b\": 233}",
      "page2": "{\"c\": \"sehr gut!\", \"d\": true}"
    },
    "presentationProgress": "none",
    "responseProgress": "some",
    "unitStateDataType": "iqb-key-value@2.1.2"
  },
  "playerState": {
    "state": "running",
    "validPages": {
      "page1": "Seite 1",
      "page2": "Seite 2"
    },
    "currentPage": "page4"
  },
  "log": [
    {
      "timeStamp": "2021-11-10T10:22:25Z",
      "key": "UNIT_NAVIGATION_FAILED",
      "content": "{\"unitId\": \"M24093EX\", \"reason\": \"responsesIncomplete\"}"
    }
  ]
}
```








<a name="channel-vopPageNavigationCommand"></a>





#### Channel Parameters







###  `publish` vopPageNavigationCommand

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>The session id flags all communication. If a message has no or empty session id, it's not processed. The session id is unique and was generated by the application. Any simple algorithm would work. The session id helps to link the correct unit with the data of the message. Using the id of the player hosting html element is less reliable, because the element could be reused with another unit.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>target </td>
  <td>string</td>
  <td><p>Id of the page matching one of the validPages given to the application by the playerState data of the StateChangedNotification.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "idk8ur5jf9ru5jk",
  "target": "page4"
}
```








<a name="channel-vopUnitNavigationRequestedNotification"></a>





#### Channel Parameters







###  `subscribe` vopUnitNavigationRequestedNotification

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>The session id flags all communication. If a message has no or empty session id, it's not processed. The session id is unique and was generated by the application. Any simple algorithm would work. The session id helps to link the correct unit with the data of the message. Using the id of the player hosting html element is less reliable, because the element could be reused with another unit.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>target </td>
  <td>string</td>
  <td><p>This enumeration lists all possible targets the player could send a navigation request for, relative to the position of the current unit. This could be the next and previous unit, last and first unit of the current range of units (booklet, testlet) or the end of the test. The ending is seen as kind of termination of test, e. g. the announcement of the testee, that all responses are given. What exactly the host will navigate to depends of the nature of the test or the use case and might depend on configuration parameters of the specific booklet as well.</p>
</td>
  <td><code>next</code>, <code>previous</code>, <code>first</code>, <code>last</code>, <code>end</code></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "idk8ur5jf9ru5jk",
  "target": "next"
}
```








<a name="channel-vopGetStateRequest"></a>





#### Channel Parameters







###  `publish` vopGetStateRequest

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>The session id flags all communication. If a message has no or empty session id, it's not processed. The session id is unique and was generated by the application. Any simple algorithm would work. The session id helps to link the correct unit with the data of the message. Using the id of the player hosting html element is less reliable, because the element could be reused with another unit.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>stop </td>
  <td>boolean</td>
  <td><p>If true, the player should not accept any user interaction anymore to be sure, that all states of the unit are reported. Usually, you will do so just before unloading the player and prepare for the next unit.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "idk8ur5jf9ru5jk",
  "stop": true
}
```








<a name="channel-vopNavigationDeniedNotification"></a>





#### Channel Parameters







###  `publish` vopNavigationDeniedNotification

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>The session id flags all communication. If a message has no or empty session id, it's not processed. The session id is unique and was generated by the application. Any simple algorithm would work. The session id helps to link the correct unit with the data of the message. Using the id of the player hosting html element is less reliable, because the element could be reused with another unit.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>reason </td>
  <td>array(string)</td>
  <td><p>This optional parameter explains the reason for the failed attempt to navigate. The player can visualise the problem to the testee. For example, all required but empty input elements get a red border or the message 'please scroll down' is presented.</p>
</td>
  <td><em>Any</em></td>
</tr>









    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "idk8ur5jf9ru5jk",
  "reason": [
    "presentationIncomplete"
  ]
}
```








<a name="channel-vopStopCommand"></a>





#### Channel Parameters







###  `publish` vopStopCommand

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>The session id flags all communication. If a message has no or empty session id, it's not processed. The session id is unique and was generated by the application. Any simple algorithm would work. The session id helps to link the correct unit with the data of the message. Using the id of the player hosting html element is less reliable, because the element could be reused with another unit.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "idk8ur5jf9ru5jk"
}
```








<a name="channel-vopContinueCommand"></a>





#### Channel Parameters







###  `publish` vopContinueCommand

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>The session id flags all communication. If a message has no or empty session id, it's not processed. The session id is unique and was generated by the application. Any simple algorithm would work. The session id helps to link the correct unit with the data of the message. Using the id of the player hosting html element is less reliable, because the element could be reused with another unit.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "idk8ur5jf9ru5jk"
}
```








<a name="channel-vopWindowFocusChangedNotification"></a>





#### Channel Parameters







###  `subscribe` vopWindowFocusChangedNotification

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>timeStamp </td>
  <td>string</td>
  <td><p>Ensures, that later arriving states are ignored.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>hasFocus </td>
  <td>boolean</td>
  <td><p>true if the player got the focus, false if it lost the focus.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "timeStamp": "2021-11-10T10:22:25Z",
  "hasFocus": true
}
```











# Verona Player Module 2.1.0 documentation



This is one part of the Verona Online Assessment Standards. All messages are sent via the postMessage function of the html page. The player takes the page root of its parent as target (parent.window), and the application binds the function call to the iframe element of the player.
Most important, the message body carries as first parameter the operationId of the message.

## Table of Contents




* [Channels](#channels)










## Channels



<a name="channel-vopReadyNotification"></a>





#### Channel Parameters







###  `subscribe` vopReadyNotification

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>apiVersion </td>
  <td>string</td>
  <td><p>This lets the application know what verona API version the player supports. The host will decide whether this declaration matches the requirements of the host or not and which features are not or differently implemented by the player.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>notSupportedApiFeatures </td>
  <td>string</td>
  <td><p>Space separated list of keys of features not implemented by the player. For details see corresponding player metadata doc!</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>supportedUnitDefinitionTypes </td>
  <td>string</td>
  <td><p>Space separated list of keys of unit definition formats supported by the player. If a version is part of the key then it's enclosed in parentheses.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>supportedUnitStateDataTypes </td>
  <td>string</td>
  <td><p>Space separated list of keys of unit state data formats supported by the player. If a version is part of the key then it's enclosed in parentheses.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "apiVersion": "string",
  "notSupportedApiFeatures": "string",
  "supportedUnitDefinitionTypes": "string",
  "supportedUnitStateDataTypes": "string"
}
```








<a name="channel-vopStartCommand"></a>





#### Channel Parameters







###  `publish` vopStartCommand

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>The session id flags all communication from this moment on. If a message has no or empty session id, it's not processed. The session id is unique and was generated by the application. Any simple algorithm would work. The session id helps to link the correct unit with the data of the message. Using the id of the player hosting html element is less reliable, because the element could be reused with another unit (via this StartCommand).</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>unitDefinition </td>
  <td>string</td>
  <td><p>The definition of the unit (if given) lets the player adapt. An audio player gets it's audio sequence, a choice player gets it's options...</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>unitDefinitionType </td>
  <td>string</td>
  <td><p>This lets the player the unit definition format know. This might avoid UI mess after getting old definitions.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>unitState </td>
  <td>object</td>
  <td><p>If there is any state what should be restored, then this is the information for that.</p>
</td>
  <td><em>Any</em></td>
</tr>





<tr>
  <td>unitState.dataParts </td>
  <td>object</td>
  <td><p>These data are used by the player to restore the former response state and by data processing systems to analyse the responses. The host must buffer all data parts, because the player might send only changed data parts, not always the whole package. The host stores all parts but only the last given version (respect timeStamp!). Every data part is identified by a unique key, the data is stored as serialized object (string).</p>
</td>
  <td><em>Any</em></td>
</tr>











<tr>
  <td>unitState.presentationProgress </td>
  <td></td>
  <td></td>
  <td><code>none</code>, <code>some</code>, <code>complete</code></td>
</tr>









<tr>
  <td>unitState.responseProgress </td>
  <td></td>
  <td></td>
  <td><code>none</code>, <code>some</code>, <code>complete</code>, <code>complete-and-valid</code></td>
</tr>









<tr>
  <td>unitState.unitStateDataType </td>
  <td>string</td>
  <td><p>This string specifies the format of the data stored in dataParts (value). Every transformation or analysis of stored unit data requires knowledge about the format. When the host sends data to the player to restore the former unit state, the player should check the given data type to avoid data mess after getting an old data type.</p>
</td>
  <td><em>Any</em></td>
</tr>











    
      
<tr>
  <td>playerConfig </td>
  <td>object</td>
  <td><p>This data supplies some information or instruction about this specific run of the unit (number, unit title, some behavioral data for the player).</p>
</td>
  <td><em>Any</em></td>
</tr>





<tr>
  <td>playerConfig.unitNumber </td>
  <td>integer</td>
  <td></td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>playerConfig.unitTitle </td>
  <td>string</td>
  <td></td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>playerConfig.unitId </td>
  <td>string</td>
  <td></td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>playerConfig.stateReportPolicy </td>
  <td></td>
  <td></td>
  <td><code>none</code>, <code>eager</code>, <code>on-demand</code></td>
</tr>









<tr>
  <td>playerConfig.logPolicy </td>
  <td></td>
  <td></td>
  <td><code>disabled</code>, <code>lean</code>, <code>rich</code>, <code>debug</code></td>
</tr>









<tr>
  <td>playerConfig.pagingMode </td>
  <td></td>
  <td></td>
  <td><code>separate</code>, <code>concat-scroll</code>, <code>concat-scroll-snap</code></td>
</tr>











    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "string",
  "unitDefinition": "string",
  "unitDefinitionType": "string",
  "unitState": {
    "dataParts": {
      "property1": "string",
      "property2": "string"
    },
    "presentationProgress": "none",
    "responseProgress": "none",
    "unitStateDataType": "string"
  },
  "playerConfig": {
    "unitNumber": 1,
    "unitTitle": "string",
    "unitId": "string",
    "stateReportPolicy": "none",
    "logPolicy": "disabled",
    "pagingMode": "separate"
  }
}
```








<a name="channel-vopStateChangedNotification"></a>





#### Channel Parameters







###  `subscribe` vopStateChangedNotification

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>Unique identificator of the execution of the unit (one run). This id was generated by the application and first given to the player via StartCommand.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>timeStamp </td>
  <td>string</td>
  <td><p>Ensures, that later arriving states are ignored.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>unitState </td>
  <td>object</td>
  <td><p>To be stored, evaluated etc. This is the main yield, the responses.</p>
</td>
  <td><em>Any</em></td>
</tr>





<tr>
  <td>unitState.dataParts </td>
  <td>object</td>
  <td><p>These data are used by the player to restore the former response state and by data processing systems to analyse the responses. The host must buffer all data parts, because the player might send only changed data parts, not always the whole package. The host stores all parts but only the last given version (respect timeStamp!). Every data part is identified by a unique key, the data is stored as serialized object (string).</p>
</td>
  <td><em>Any</em></td>
</tr>











<tr>
  <td>unitState.presentationProgress </td>
  <td></td>
  <td></td>
  <td><code>none</code>, <code>some</code>, <code>complete</code></td>
</tr>









<tr>
  <td>unitState.responseProgress </td>
  <td></td>
  <td></td>
  <td><code>none</code>, <code>some</code>, <code>complete</code>, <code>complete-and-valid</code></td>
</tr>









<tr>
  <td>unitState.unitStateDataType </td>
  <td>string</td>
  <td><p>This string specifies the format of the data stored in dataParts (value). Every transformation or analysis of stored unit data requires knowledge about the format. When the host sends data to the player to restore the former unit state, the player should check the given data type to avoid data mess after getting an old data type.</p>
</td>
  <td><em>Any</em></td>
</tr>











    
      
<tr>
  <td>playerState </td>
  <td>object</td>
  <td><p>Information important only for the application to ensure the correct visual, such as navigation buttons.</p>
</td>
  <td><em>Any</em></td>
</tr>





<tr>
  <td>playerState.state </td>
  <td></td>
  <td></td>
  <td><code>running</code>, <code>stopped</code></td>
</tr>









<tr>
  <td>playerState.validPages </td>
  <td>object</td>
  <td><p>These data are structured as &quot;page key&quot; =&gt; &quot;page label&quot;, so we have (1) keys for navigation commands or state notifications and (2) strings as labels of navigation buttons if needed.</p>
</td>
  <td><em>Any</em></td>
</tr>











<tr>
  <td>playerState.currentPage </td>
  <td>string</td>
  <td><p>Key of the page currently presented. This key is taken from the list of valid pages. If the paging mode is 'concat-scroll', the first page with parts in view port is taken as current page.</p>
</td>
  <td><em>Any</em></td>
</tr>











    
      
<tr>
  <td>log </td>
  <td>array(object)</td>
  <td><p>Log entries (lean version) add some information to the response in order to understand the response process better or (rich version) let the analyst replay every change of the state.</p>
</td>
  <td><em>Any</em></td>
</tr>








<tr>
  <td>log.timeStamp </td>
  <td>string</td>
  <td></td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>log.key </td>
  <td>string</td>
  <td><p>This key might help to classify the events afterwards.</p>
</td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>log.content </td>
  <td>string</td>
  <td><p>Some information to specify the event.</p>
</td>
  <td><em>Any</em></td>
</tr>










    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "string",
  "timeStamp": "2020-08-23T08:36:59Z",
  "unitState": {
    "dataParts": {
      "property1": "string",
      "property2": "string"
    },
    "presentationProgress": "none",
    "responseProgress": "none",
    "unitStateDataType": "string"
  },
  "playerState": {
    "state": "running",
    "validPages": {
      "property1": "string",
      "property2": "string"
    },
    "currentPage": "string"
  },
  "log": [
    {
      "timeStamp": "2020-08-23T08:36:59Z",
      "key": "string",
      "content": "string"
    }
  ]
}
```








<a name="channel-vopPageNavigationCommand"></a>





#### Channel Parameters







###  `publish` vopPageNavigationCommand

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>Unique identificator of the execution of the unit (one run). This id was generated by the application and first given to the player via StartCommand.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>target </td>
  <td>string</td>
  <td><p>Id of the page matching one of the validPages given to the application by the playerState data of the StateChangedNotification.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "string",
  "target": "string"
}
```








<a name="channel-vopUnitNavigationRequestedNotification"></a>





#### Channel Parameters







###  `subscribe` vopUnitNavigationRequestedNotification

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>Unique identificator of the execution of the unit (one run). This id was generated by the application and first given to the player via StartCommand.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>targetRelative </td>
  <td></td>
  <td><p>Refers to a unit relative to the position of the current unit or to the first or last unit. The key 'end' requests the finish of the test (close and go to the thank you page).</p>
</td>
  <td><code>next</code>, <code>previous</code>, <code>first</code>, <code>last</code>, <code>end</code></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "string",
  "targetRelative": "next"
}
```








<a name="channel-vopGetStateRequest"></a>





#### Channel Parameters







###  `publish` vopGetStateRequest

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>Unique identificator of the execution of the unit (one run). This id was generated by the application and first given to the player via StartCommand.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>stop </td>
  <td>boolean</td>
  <td><p>If true, the player should not accept any user interaction anymore to be sure, that all states of the unit are reported. Usually, you will do so just before unloading the player and prepare for the next unit.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "string",
  "stop": true
}
```








<a name="channel-vopGetStateResponse"></a>





#### Channel Parameters







###  `subscribe` vopGetStateResponse

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>Unique identificator of the execution of the unit (one run). This id was generated by the application and first given to the player via StartCommand.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>timeStamp </td>
  <td>string</td>
  <td></td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>unitState </td>
  <td>object</td>
  <td></td>
  <td><em>Any</em></td>
</tr>





<tr>
  <td>unitState.dataParts </td>
  <td>object</td>
  <td><p>These data are used by the player to restore the former response state and by data processing systems to analyse the responses. The host must buffer all data parts, because the player might send only changed data parts, not always the whole package. The host stores all parts but only the last given version (respect timeStamp!). Every data part is identified by a unique key, the data is stored as serialized object (string).</p>
</td>
  <td><em>Any</em></td>
</tr>











<tr>
  <td>unitState.presentationProgress </td>
  <td></td>
  <td></td>
  <td><code>none</code>, <code>some</code>, <code>complete</code></td>
</tr>









<tr>
  <td>unitState.responseProgress </td>
  <td></td>
  <td></td>
  <td><code>none</code>, <code>some</code>, <code>complete</code>, <code>complete-and-valid</code></td>
</tr>









<tr>
  <td>unitState.unitStateDataType </td>
  <td>string</td>
  <td><p>This string specifies the format of the data stored in dataParts (value). Every transformation or analysis of stored unit data requires knowledge about the format. When the host sends data to the player to restore the former unit state, the player should check the given data type to avoid data mess after getting an old data type.</p>
</td>
  <td><em>Any</em></td>
</tr>











    
      
<tr>
  <td>playerState </td>
  <td>object</td>
  <td></td>
  <td><em>Any</em></td>
</tr>





<tr>
  <td>playerState.state </td>
  <td></td>
  <td></td>
  <td><code>running</code>, <code>stopped</code></td>
</tr>









<tr>
  <td>playerState.validPages </td>
  <td>object</td>
  <td><p>These data are structured as &quot;page key&quot; =&gt; &quot;page label&quot;, so we have (1) keys for navigation commands or state notifications and (2) strings as labels of navigation buttons if needed.</p>
</td>
  <td><em>Any</em></td>
</tr>











<tr>
  <td>playerState.currentPage </td>
  <td>string</td>
  <td><p>Key of the page currently presented. This key is taken from the list of valid pages. If the paging mode is 'concat-scroll', the first page with parts in view port is taken as current page.</p>
</td>
  <td><em>Any</em></td>
</tr>











    
      
<tr>
  <td>log </td>
  <td>array(object)</td>
  <td></td>
  <td><em>Any</em></td>
</tr>








<tr>
  <td>log.timeStamp </td>
  <td>string</td>
  <td></td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>log.key </td>
  <td>string</td>
  <td><p>This key might help to classify the events afterwards.</p>
</td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>log.content </td>
  <td>string</td>
  <td><p>Some information to specify the event.</p>
</td>
  <td><em>Any</em></td>
</tr>










    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "string",
  "timeStamp": "2020-08-23T08:36:59Z",
  "unitState": {
    "dataParts": {
      "property1": "string",
      "property2": "string"
    },
    "presentationProgress": "none",
    "responseProgress": "none",
    "unitStateDataType": "string"
  },
  "playerState": {
    "state": "running",
    "validPages": {
      "property1": "string",
      "property2": "string"
    },
    "currentPage": "string"
  },
  "log": [
    {
      "timeStamp": "2020-08-23T08:36:59Z",
      "key": "string",
      "content": "string"
    }
  ]
}
```








<a name="channel-vopStopCommand"></a>





#### Channel Parameters







###  `publish` vopStopCommand

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>Unique identificator of the execution of the unit (one run). This id was generated by the application and first given to the player via StartCommand.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "string"
}
```








<a name="channel-vopContinueCommand"></a>





#### Channel Parameters







###  `publish` vopContinueCommand

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>Unique identificator of the execution of the unit (one run). This id was generated by the application and first given to the player via StartCommand.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "string"
}
```








<a name="channel-vopWindowsFocusChangedNotification"></a>





#### Channel Parameters







###  `subscribe` vopWindowsFocusChangedNotification

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>timeStamp </td>
  <td>string</td>
  <td><p>Ensures, that later arriving states are ignored.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>hasFocus </td>
  <td>boolean</td>
  <td><p>true if the player got the focus, false if it lost the focus.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "timeStamp": "2020-08-23T08:36:59Z",
  "hasFocus": true
}
```










